package aoc.event.year2016.day04.securityThroughObscurity;

import aoc.PuzzleSolver;

import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Solution implements PuzzleSolver
{
    /// Matches the data for the room input.
    private static final Pattern ROOM_PATTERN = Pattern.compile("([\\w-]+)-(\\d+)\\[(\\w+)]");
    
    /// Stores the data for a room.
    record Room(String encryptedName, int sectorId, String checksum) {}
    
    /// Parses a line of the puzzle input for the room data.
    ///
    /// A room input is in the format: `aa-bbb-cc-dd-e-836[abcde]`.
    ///
    /// Each input contains three parts:
    ///
    /// - The first part of the string, `aa-bbb-cc-dd-e` is the room name.
    /// - The second part of the string, `836` is the sector id.
    /// - The third part of the string, `abcde` is the checksum.
    ///
    /// @param line the puzzle input for a room.
    /// @return a new Room created from the parsed data.
    /// @throws IllegalArgumentException if the input does not match the expected pattern.
    private static Room parseRoom(String line)
    {
        Matcher matcher = ROOM_PATTERN.matcher(line);
        
        if (matcher.find())
        {
            String encryptedName = matcher.group(1);
            int sectorId = Integer.parseInt(matcher.group(2));
            String checksum = matcher.group(3);
            
            encryptedName = encryptedName.replaceAll("-", "");
            
            return new Room(encryptedName, sectorId, checksum);
        }
        else
        {
            throw new IllegalArgumentException(
                    "Input line did not match expected pattern: " + line
            );
        }
    }
    
    /// Calculates the sum of the sector ids of the real rooms.
    ///
    /// A room is real if its checksum matches.
    ///
    /// @param inputLines the puzzle input, containing a list of rooms.
    /// @return the sum of the sector ids of the real rooms
    @Override
    public Object partOne(List<String> inputLines)
    {
        int sectorIdSum = 0;
        
        for (String line : inputLines)
        {
            Room room = parseRoom(line);
            String encryptedName = room.encryptedName.replaceAll("-", "");
            
            String realChecksum = generateChecksum(encryptedName);
            boolean realRoom = realChecksum.equals(room.checksum);
            
            if (realRoom)
            {
                sectorIdSum += room.sectorId;
            }
        }
        
        return sectorIdSum;
    }
    
    /// Generates a checksum from the encrypted name.
    ///
    /// A checksum is generated by appending the 5 most common letters in the encrypted name,
    /// with ties broken by alphabetical order.
    ///
    /// @param encryptedName the encrypted name of a room.
    /// @return the checksum of the encrypted name.
    private static String generateChecksum(String encryptedName)
    {
        Map<Character, Integer> letterCount = getLetterCount(encryptedName);
        List<Character> letters = new ArrayList<>(letterCount.keySet());
        
        Comparator<Character> comparator = getLetterComparator(letterCount);
        letters.sort(comparator);
        
        StringBuilder checksumBuilder = new StringBuilder();
        
        for (int index = 0; index < 5; index++)
        {
            checksumBuilder.append(letters.get(index));
        }
        
        return checksumBuilder.toString();
    }
    
    /// Counts the occurrences of the characters in the string.
    ///
    /// @param string a string.
    /// @return a mapping of the characters and their counts.
    private static Map<Character, Integer> getLetterCount(String string)
    {
        Map<Character, Integer> letterCount = new HashMap<>();
        
        for (int index = 0; index < string.length(); index++)
        {
            char letter = string.charAt(index);
            int count = letterCount.getOrDefault(letter, 0) + 1;
            
            letterCount.put(letter, count);
        }
        
        return letterCount;
    }
    
    /// Creates a comparator to compare the letters by their counts, with ties broken by
    /// alphabetical order.
    ///
    /// The letters should be compared such that the letters with higher counts are placed before
    /// letters with lower counts (non-increasing order). If two letters have the same count,
    /// then ordering is decided alphabetically.
    ///
    /// @param letterCount a map of the characters and their counts.
    /// @return a comparator for the letters and their counts.
    private static Comparator<Character> getLetterComparator(Map<Character, Integer> letterCount)
    {
        return (predecessor, successor) ->
        {
            int predecessorCount = letterCount.get(predecessor);
            int successorCount = letterCount.get(successor);
            
            if (predecessorCount < successorCount)
            {
                return 1;
            }
            else if (predecessorCount == successorCount)
            {
                return predecessor.compareTo(successor);
            }
            else
            {
                return -1;
            }
        };
    }
    
    /// Finds the sector id of the room that stores North Pole objects.
    ///
    /// All rooms have encrypted names, and each room name must be decrypted before it can be
    /// determined what type of room it is.
    ///
    /// @param inputLines the puzzle input, containing a list of rooms.
    /// @return the sector id of the North Pole object storage.
    /// @throws IllegalArgumentException if there are no North Pole objects.
    @Override
    public Object partTwo(List<String> inputLines)
    {
        for (String line : inputLines)
        {
            Room room = parseRoom(line);
            String decryptedName = decryptName(room);
            
            if (decryptedName.contains("north") && decryptedName.contains("pole"))
            {
                return room.sectorId;
            }
        }
        
        throw new IllegalArgumentException("The North Pole object storage was not found");
    }
    
    /// Decrypts the encrypted name of the room.
    ///
    /// Decryption is performed by implementing a shift-cipher, where each character in the room
    /// name is shifted forward `m` times, where `m` is the sector id of the room.
    ///
    /// Each shift is performed such that `A` turns to `B`, `B` turns to `C`, `Z` turns to `A`,
    /// etc. Dashes are converted to spaces.
    ///
    /// @param room a room.
    /// @return the decrypted name of the room.
    private static String decryptName(Room room)
    {
        StringBuilder decryptedNameBuilder = new StringBuilder();
        
        int sectorOffset = room.sectorId % 26;
        
        for (int index = 0; index < room.encryptedName.length(); index++)
        {
            char character = room.encryptedName.charAt(index);
            
            if (character == '-')
            {
                decryptedNameBuilder.append(" ");
            }
            else
            {
                char decryptedCharacter = (char) (character + sectorOffset);
                
                if (decryptedCharacter > 'z')
                {
                    decryptedCharacter -= 26;
                }
                
                decryptedNameBuilder.append(decryptedCharacter);
            }
        }
        
        return decryptedNameBuilder.toString();
    }
}
