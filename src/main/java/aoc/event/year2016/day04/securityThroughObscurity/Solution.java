package aoc.event.year2016.day04.securityThroughObscurity;

import aoc.Runner;
import aoc.Solver;

import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Solution implements Solver {
    
    /// Matches the data for the room input.
    private static final Pattern ROOM_PATTERN = Pattern.compile("([\\w-]+)-(\\d+)\\[(\\w+)]");
    
    private final List<Room> rooms;
    
    public Solution(String input) {
        rooms = parse(input);
    }
    
    /// Parses the puzzle input for the room data.
    ///
    /// A room input is in the format: `aa-bbb-cc-dd-e-836[abcde]`.
    ///
    /// Each input contains three parts:
    ///
    /// - The first part of the string, `aa-bbb-cc-dd-e` is the room name.
    /// - The second part of the string, `836` is the sector id.
    /// - The third part of the string, `abcde` is the checksum.
    ///
    /// @param input the puzzle input.
    /// @return a list of rooms from the parsed data.
    /// @throws IllegalArgumentException if the input does not match the expected pattern.
    private static List<Room> parse(String input) {
        final var rooms = new ArrayList<Room>();
        
        for (final var line : input.lines().toList()) {
            Matcher matcher = ROOM_PATTERN.matcher(line);
            
            if (matcher.find()) {
                String encryptedName = matcher.group(1);
                int sectorId = Integer.parseInt(matcher.group(2));
                String checksum = matcher.group(3);
                
                final var room = new Room(encryptedName, sectorId, checksum);
                rooms.add(room);
            } else {
                throw new IllegalArgumentException(
                    "Input line did not match expected pattern: " + line
                );
            }
        }
        
        return rooms;
    }
    
    /// Calculates the sum of the sector ids of the real rooms.
    ///
    /// A room is real if its checksum matches.
    ///
    /// @return the sum of the sector ids of the real rooms
    @Override
    public Object partOne() {
        int sectorIdSum = 0;
        
        for (final var room : rooms) {
            String encryptedName = room.encryptedName.replaceAll("-", "");
            
            String realChecksum = generateChecksum(encryptedName);
            boolean realRoom = realChecksum.equals(room.checksum);
            
            if (realRoom) {
                sectorIdSum += room.sectorId;
            }
        }
        
        return sectorIdSum;
    }
    
    /// Generates a checksum from the encrypted name.
    ///
    /// A checksum is generated by appending the 5 most common letters in the encrypted name,
    /// with ties broken by alphabetical order.
    ///
    /// @param encryptedName the encrypted name of a room.
    /// @return the checksum of the encrypted name.
    private static String generateChecksum(String encryptedName) {
        Map<Character, Integer> letterCount = getLetterCount(encryptedName);
        List<Character> letters = new ArrayList<>(letterCount.keySet());
        
        Comparator<Character> comparator = getLetterComparator(letterCount);
        letters.sort(comparator);
        
        StringBuilder checksumBuilder = new StringBuilder();
        
        for (int index = 0; index < 5; index++) {
            checksumBuilder.append(letters.get(index));
        }
        
        return checksumBuilder.toString();
    }
    
    /// Counts the occurrences of the characters in the string.
    ///
    /// @param string a string.
    /// @return a mapping of the characters and their counts.
    private static Map<Character, Integer> getLetterCount(String string) {
        Map<Character, Integer> letterCount = new HashMap<>();
        
        for (int index = 0; index < string.length(); index++) {
            char letter = string.charAt(index);
            int count = letterCount.getOrDefault(letter, 0) + 1;
            
            letterCount.put(letter, count);
        }
        
        return letterCount;
    }
    
    /// Creates a comparator to compare the letters by their counts, with ties broken by
    /// alphabetical order.
    ///
    /// The letters should be compared such that the letters with higher counts are placed before
    /// letters with lower counts (non-increasing order). If two letters have the same count,
    /// then ordering is decided alphabetically.
    ///
    /// @param letterCount a map of the characters and their counts.
    /// @return a comparator for the letters and their counts.
    private static Comparator<Character> getLetterComparator(Map<Character, Integer> letterCount) {
        return (predecessor, successor) ->
        {
            int predecessorCount = letterCount.get(predecessor);
            int successorCount = letterCount.get(successor);
            
            if (predecessorCount < successorCount) {
                return 1;
            } else if (predecessorCount == successorCount) {
                return predecessor.compareTo(successor);
            } else {
                return -1;
            }
        };
    }
    
    /// Finds the sector id of the room that stores North Pole objects.
    ///
    /// All rooms have encrypted names, and each room name must be decrypted before it can be
    /// determined what type of room it is.
    ///
    /// @return the sector id of the North Pole object storage.
    /// @throws IllegalArgumentException if there are no North Pole objects.
    @Override
    public Object partTwo() {
        for (final var room : rooms) {
            String decryptedName = decryptName(room);
            
            if (decryptedName.contains("north") && decryptedName.contains("pole")) {
                return room.sectorId;
            }
        }
        
        throw new IllegalArgumentException("The North Pole object storage was not found");
    }
    
    /// Decrypts the encrypted name of the room.
    ///
    /// Decryption is performed by implementing a shift-cipher, where each character in the room
    /// name is shifted forward `m` times, where `m` is the sector id of the room.
    ///
    /// Each shift is performed such that `A` turns to `B`, `B` turns to `C`, `Z` turns to `A`,
    /// etc. Dashes are converted to spaces.
    ///
    /// @param room a room.
    /// @return the decrypted name of the room.
    private static String decryptName(Room room) {
        StringBuilder decryptedNameBuilder = new StringBuilder();
        int sectorOffset = room.sectorId % 26;
        
        for (int index = 0; index < room.encryptedName.length(); index++) {
            char character = room.encryptedName.charAt(index);
            
            if (character == '-') {
                decryptedNameBuilder.append(" ");
            } else {
                char decryptedCharacter = (char) (character + sectorOffset);
                
                if (decryptedCharacter > 'z') {
                    decryptedCharacter -= 26;
                }
                
                decryptedNameBuilder.append(decryptedCharacter);
            }
        }
        
        return decryptedNameBuilder.toString();
    }
    
    /// Stores the data for a room.
    record Room(String encryptedName, int sectorId, String checksum) {}
    
    public static void main(String[] args) {
        Runner.runAndPrint(2016, 4);
    }
}
